:py:mod:`hypso.classification.WaterDetect.waterdetect`
======================================================

.. py:module:: hypso.classification.WaterDetect.waterdetect


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   Common/index.rst
   External_mask/index.rst
   Glint/index.rst
   Image/index.rst
   InputOutput/index.rst
   WaterDetect/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   hypso.classification.WaterDetect.waterdetect.DWProducts
   hypso.classification.WaterDetect.waterdetect.DWWaterDetect
   hypso.classification.WaterDetect.waterdetect.DWImageClustering
   hypso.classification.WaterDetect.waterdetect.DWutils
   hypso.classification.WaterDetect.waterdetect.DWConfig



Functions
~~~~~~~~~

.. autoapisummary::

   hypso.classification.WaterDetect.waterdetect.prepare_external_masks



Attributes
~~~~~~~~~~

.. autoapisummary::

   hypso.classification.WaterDetect.waterdetect.__version__
   hypso.classification.WaterDetect.waterdetect.gdal


.. py:data:: __version__
   :value: '1.5.15'

   

.. py:class:: DWProducts


   .. py:attribute:: Landsat8_USGS
      :value: 'L8_USGS'

      

   .. py:attribute:: Sentinel2_THEIA
      :value: 'S2_THEIA'

      

   .. py:attribute:: Sentinel2_ESA
      :value: 'S2_S2COR'

      

   .. py:attribute:: Sentinel2_L1C
      :value: 'S2_L1C'

      


.. py:data:: gdal

   

.. py:class:: DWWaterDetect(input_folder, output_folder, shape_file, product, config_file, pekel=None, single_mode=False, *args, **kwargs)


   .. py:property:: water_mask


   .. py:property:: cluster_matrix


   .. py:method:: __repr__()

      Return repr(self).


   .. py:method:: necessary_bands(include_rgb)

      Return all the necessary bands, based on the bands used for the graphics and the clustering
      :param include_rgb: Specifies if RGB bands are necessary for creating composite, for example
      :return: All necessary bands in a list


   .. py:method:: calc_nd_index(index_name, band1, band2, save_index=False)

      Calculates a normalized difference index, adds it to the bands dict and update the mask in loader
      :param save_index: Indicate if we should save this index to a raster image
      :param index_name: name of index to be used as key in the dictionary
      :param band1: first band to be used in the normalized difference
      :param band2: second band to be used in the normalized difference
      :return: index array


   .. py:method:: calc_m_nd_index(index_name, band1, band2, band3, band4, save_index=False)

      Calculates a modified normalized difference index, adds it to the bands dict and update the mask in loader.
      Proposed by Dhalton. It uses the maximum of visible and the minimum of Nir/Swir
      :param save_index: Inidicate if we should save this index to a raster image
      :param index_name: name of index to be used as key in the dictionary
      :param band1: first band to be used in the normalized difference
      :param band2: second option for the first band to be used in the normalized difference
      :param band3: second band to be used in the normalized difference
      :param band4: second option for the second band to be used in the normalized difference
      :return: index array


   .. py:method:: calc_mbwi(bands, factor=3, save_index=False)

      Calculates the Multi band Water Index and adds it to the bands dictionary
      :param save_index: Inform if the index should be saved as array in the output folder
      :param bands: Bands dictionary with the raster bands
      :param factor: Factor to multiply the Green band as proposed in the original paper
      :return: mbwi array


   .. py:method:: calc_awei(bands, save_index=False)

      Calculates the AWEI Water Index and adds it to the bands dictionary
      :param save_index: Inform if the index should be saved as array in the output folder
      :param bands: Bands dictionary with the raster bands
      :return: mbwi array


   .. py:method:: run_water_detect(input_folder, output_folder, single_mode, shape_file=None, product='S2_THEIA', config_file=None, pekel=None, post_callback=None, **kwargs)
      :classmethod:

      Main function to launch the water detect algorithm processing. This is the function called from the script.
      @param input_folder: If single_mode=True, this is the uncompressed image product. If single_mode=False, this
      is the folder that contains all uncompressed images.
      @param output_folder: Output directory
      @param single_mode: For batch processing (multiple images at a time), single_mode should be set to False
      @param shape_file: Shape file to clip the image (optional).
      @param product: The product to be processed (S2_THEIA, L8_USGS, S2_L1C or S2_S2COR)
      @param config_file: Configuration .ini file. If not specified WaterDetect.ini from current dir and used as
                          default
      @param pekel: Optional path for an occurrence base map like Pekel
      @param post_callback: Used for the WaterQuality add-on package
      @param kwargs: Additional parameters.
      @return: DWWaterDetect instance with the generated mask.


   .. py:method:: _detect_water(post_callback=None)

      Run batch is intended for multi processing of various images and bands combinations.
      It Loops through all unzipped images in input folder, extract water pixels and save results to output folder
      ATT: The input folder is not a satellite image itself. It should be the parent folder containing all images.
      For single detection, use run() method.
      :return: None


   .. py:method:: test_pekel(image, dw_image, pdf_merger_image)


   .. py:method:: save_report(report_name, pdf_merger, folder)
      :staticmethod:


   .. py:method:: save_graphs(dw_image, pdf_merger_image)


   .. py:method:: create_water_mask(band_combination, pdf_merger_image, glint_processor=None)


   .. py:method:: create_colorbar_pdf(param_name, colormap, min_value, max_value, units='')


   .. py:method:: create_rgb_burn_in_pdf(product_name, burn_in_arrays, colors=None, min_value=None, max_value=None, fade=None, opt_relative_path=None, colormap='viridis', uniform_distribution=False, no_data_value=0, valid_value=1, transps=None, bright=5.0)


   .. py:method:: calc_indexes(image, indexes_list, save_index=False)



.. py:class:: DWImageClustering(bands, bands_keys, invalid_mask, config, glint_processor=None)


   .. py:property:: product_name


   .. py:method:: get_necessary_bands()

      Check the config file and all the parametrization to return a set of bands needed to run the algorithm


   .. py:method:: check_necessary_bands(bands, bands_keys, invalid_mask)

      Check if the bands_keys combination for the clustering algorithm are available in bands
      and if they all have the same shape
      :param invalid_mask: array mask with the invalid pixels
      :param bands: image bands available
      :param bands_keys: bands combination
      :return: bands and bands_keys


   .. py:method:: bands_to_columns()

      Convert self.bands to a column type matrix where each band is a column
      It follows the order of the keys ordered
      :return: column type matrix


   .. py:method:: apply_cluster(data)

      Apply the cluster algorithm to the data. Number of cluster is in self.best_k
      :param data: data to be clustered
      :return: Vector with the labels


   .. py:method:: find_best_k(data)

      Find the best number of clusters according to an metrics.
      :param data: data to be tested
      :return: number of clusters


   .. py:method:: calc_clusters_params(data, clusters_labels)

      Calculate parameters for each encountered cluster.
      Mean, Variance, Std-dev
      :param data: Clustered data
      :param clusters_labels: Labels for the data
      :return: List with cluster statistics


   .. py:method:: identify_water_cluster()

      Finds the water cluster within all the clusters.
      It can be done using MNDWI, MBWI or Mir2 bands
      :return: water cluster object


   .. py:method:: detect_cluster(param, logic, band1, band2=None)

      Detects a cluster according to a specific metrics
      :param param: Which parameter to search (mean, std-dev, variance,  ...)
      :param logic: Max or Min
      :param band1: The band related to the parameter
      :param band2:
      :return: Cluster object that satisfies the logic


   .. py:method:: supervised_classification(data, train_data, clusters_labels)

      Applies a machine learning supervised classification
      :param data: new data to be classified
      :param train_data: reference data
      :param clusters_labels: labels for the reference data
      :return: labels for the new data


   .. py:method:: apply_svm(data, clusters_labels, clusters_data)
      :staticmethod:

      Apply Support Vector Machine to classify data
      :param data: new data to be classified
      :param clusters_labels: labels for the reference data
      :param clusters_data: reference data
      :return: labels for the new data


   .. py:method:: apply_naive_bayes(data, clusters_labels, clusters_data)
      :staticmethod:

      Apply Naive Bayes classifier to classify data
      :param data: new data to be classified
      :param clusters_labels: labels for the reference data
      :param clusters_data: reference data
      :return: labels for the new data


   .. py:method:: apply_mlp(data, clusters_labels, clusters_data)
      :staticmethod:

      Apply Multilayer Perceptron classifier to classify data
      :param data: new data to be classified
      :param clusters_labels: labels for the reference data
      :param clusters_data: reference data
      :return: labels for the new data


   .. py:method:: get_cluster_param(clusters_params, k, param, band)


   .. py:method:: verify_cluster(clusters_params, k)


   .. py:method:: create_matrice_cluster(indices_array)

      Recreates the matrix with the original shape with the cluster labels for each pixel
      :param indices_array: position of the clustered pixels in the matrix
      :return: clustered image (0-no data, 1-water, 2, 3, ... - other)


   .. py:method:: split_data_by_bands(data, selected_keys)

      Gets data in column format (each band is a column) and returns only the desired bands
      :param data: data in column format
      :param selected_keys: bands keys to be extracted
      :return: data in column format only with the selected bands


   .. py:method:: create_product_name()


   .. py:method:: apply_canny_treshold()


   .. py:method:: apply_otsu_treshold()


   .. py:method:: run_detect_water(config=None)

      Runs the detect_water function
      :param config: Options dictionary for the processing
      :return: clustered matrix where 1= water


   .. py:method:: index_of_key(key)


   .. py:method:: separate_high_low_mndwi()


   .. py:method:: apply_clustering()



.. py:class:: DWutils


   .. py:attribute:: indices

      

   .. py:method:: parse_sat_name(folder, img_type='S2_THEIA')
      :staticmethod:


   .. py:method:: parse_planetary_name(name)
      :staticmethod:

      Get the string with a MS PLANETARY name and extract the useful information from it.
      @param name: Image name
      @return: Dictionary with the values.


   .. py:method:: parse_maja_name(name)
      :staticmethod:

      Get the string with a MAJA img name (THEIA format) and extract the useful information from it.
      @param name: Image name
      @return: Dictionary with the values.


   .. py:method:: parse_s2cor_name(name)
      :staticmethod:

      Get the string with a S2COR name (.SAFE format) and extract the useful information from it.
      @param name: Image name
      @return: Dictionary with the values.


   .. py:method:: bitwise_or(array, bit_values)
      :staticmethod:


   .. py:method:: bitwise_and(array, bit_values)
      :staticmethod:


   .. py:method:: flatten(x)
      :staticmethod:


   .. py:method:: listify(lst, uniques=[])
      :staticmethod:


   .. py:method:: check_path(path_str, is_dir=False)
      :staticmethod:

      Check if the path/file exists and returns a Path variable with it
      :param path_str: path string to test
      :param is_dir: whether if it is a directory or a file
      :return: Path type variable


   .. py:method:: get_directories(input_folder)
      :staticmethod:

      Return a list of directories in input_folder. These folders are the repository for satellite products
      :param input_folder: folder that stores the images
      :return: list of images (i.e. directories)


   .. py:method:: calc_normalized_difference(img1, img2, mask=None, compress_cte=0.02)
      :staticmethod:

      Calc the normalized difference of given arrays (img1 - img2)/(img1 + img2).
      Updates the mask if any invalid numbers (ex. np.inf or np.nan) are encountered
      :param img1: first array
      :param img2: second array
      :param mask: initial mask, that will be updated
      :param compress_cte: amount of index compression. The greater, the more the index will be compressed towards 0
      :return: nd array filled with -9999 in the mask and the mask itself


   .. py:method:: calc_mbwi(bands, factor, mask)
      :staticmethod:


   .. py:method:: rgb_burn_in(red, green, blue, burn_in_array, color=None, min_value=None, max_value=None, colormap='viridis', fade=1, uniform_distribution=False, no_data_value=-9999, valid_value=1, transp=0.0)
      :staticmethod:

      Burn in a mask or a specific parameter into an RGB image for visualization purposes.
      The burn_in_array will be copied where values are different from no_data_value.
      :param uniform_distribution: convert the input values in a uniform histogram
      :param colormap: matplotlib colormap (string) to create the RGB ramp
      :param max_value: maximum value
      :param min_value: minimum value
      :param red: Original red band
      :param green: Original green band
      :param blue: Original blue band
      :param burn_in_array: Values to be burnt in
      :param no_data_value: Value to ne unconsidered
      :param color: Tuple of color (R, G, B) to be used in the burn in
      :param fade: Fade the RGB bands to emphasize the copied values
      :param transp: Transparency to use in the mask (0=opaque 1=completely transparent)
      :return: RGB image bands


   .. py:method:: apply_mask(array, mask, no_data_value=-9999, clear_nan=True)
      :staticmethod:


   .. py:method:: gray2color_ramp(grey_array, color1=(0.0, 0.0, 0.6), color2=(0.0, 0.8, 0.0), color3=(1.0, 0.0, 0.0), min_value=0, max_value=20, colormap='viridis', limits=(0, 1))
      :staticmethod:

      Convert a greyscale n-dimensional matrix into a rgb matrix, adding 3 dimensions to it for R, G, and B
      The colors will be mixed
      :param max_value: Maximum value for the color ramp, if None, we consider max(grey)
      :param min_value: Minimum value for the color ramp, if None, we consider min(grey)
      :param grey_array: greyscale vector/matrix
      :param color1: Color for the minimum value
      :param color2: Color for the mid value
      :param color3: Color for the maximum value
      :param limits: Final boundary limits for the RGB values
      :return: Colored vector/matrix


   .. py:method:: array2raster(filename, array, geo_transform, projection, nodatavalue=0, dtype=None)
      :staticmethod:


   .. py:method:: array2rgb_raster(filename, red, green, blue, geo_transform, projection, nodatavalue=-9999)
      :staticmethod:


   .. py:method:: tif_2_pdf(tif_file, resolution=600, scale=2000)
      :staticmethod:

      Convert a TIF image into a PDF given a resolution


   .. py:method:: array2multiband(filename, array, geo_transform, projection, nodatavalue=0, dtype=None)
      :staticmethod:


   .. py:method:: get_train_test_data(data, train_size, min_train_size, max_train_size)
      :staticmethod:

      Split the provided data in train-test bunches
      :param min_train_size: minimum data quantity for train set
      :param max_train_size: maximum data quantity for train set
      :param train_size: percentage of the data to be used as train dataset
      :param data: data to be split
      :return: train and test datasets


   .. py:method:: plot_clustered_data(data, cluster_names, file_name, graph_options, pdf_merger)
      :staticmethod:


   .. py:method:: plot_graphs(bands, graphs_bands, labels_array, file_name, graph_title, invalid_mask=False, max_points=1000, pdf_merger=None)
      :staticmethod:


   .. py:method:: create_composite(bands, folder_name, pdf=True, resolution=600, offset=0)
      :staticmethod:


   .. py:method:: create_bands_dict(bands_array, bands_order)
      :staticmethod:


   .. py:method:: create_colorbar_pdf(product_name, title, label, colormap, min_value, max_value, log_scale=False)
      :staticmethod:


   .. py:method:: find_file_glob(file_string, folder)
      :staticmethod:


   .. py:method:: read_gdal_ds(file, shape_file, temp_dir)
      :staticmethod:

      Read a GDAL dataset clipping it with a given shapefile, if necessary
      :param file: Filepath of the GDAL file (.tif, etc.) as Pathlib
      :param shape_file: file path of the shapefile
      :param temp_dir: file path of the temporary directory
      :return: GDAL dataset


   .. py:method:: extract_angles_from_xml(xml)
      :staticmethod:

      Function to extract Zenith and Azimuth angles values from an xml Sentinel 2 file

      Parameters
      ----------
      xml : TYPE xml file
          DESCRIPTION Filepath of the metadata file from L2A Sentinel 2 data: example "SENTINEL2A_20200328-104846-345_L2A_T31TFJ_C_V2-2_MTD_ALL.xml"

      :return g: list of glint values

      Info
      -------
      SZA : TYPE float
          DESCRIPTION. Sun zenith angle
      SazA : TYPE float
          DESCRIPTION. Sun azimuth angle
      zenith_angle : TYPE list of strings
          DESCRIPTION. Mean_Viewing_Incidence_Angle_List for all the bands
      azimuth_angle : TYPE list of strings
          DESCRIPTION. Mean_Viewing_Incidence_Angle_List for all the bands



   .. py:method:: write_pdf(filename, text, size=(300, 50), position=(5, 5), font_color=(0, 0, 0))
      :staticmethod:


   .. py:method:: create_glint_pdf(xml, name_img, output_folder, g, pdf_merger)
      :staticmethod:

      Function to create an image to add in the pdf report that indicates if there is glint on an image

      Parameters
      ----------
      xml : TYPE xml file
          DESCRIPTION Filepath of the metadata file from L2A Sentinel 2 data: example "SENTINEL2A_20200328-104846-345_L2A_T31TFJ_C_V2-2_MTD_ALL.xml"
      current_imagename : getting current image name
      output_folder: filepath of the output folder
      g: TYPE list
          DESCRIPTION list with glint values for each band of the Sentinel 2 product
      pdf_merger: function to add an element to a pdf



   .. py:method:: remove_negatives(bands, mask=None, negative_values='mask')
      :staticmethod:

      Remove negatives values of given arrays b1 and b2, except masked values.

      :param bands: list of bands to be adjusted
      :param mask: initial mask
      :param negative_values: mask - mask the negative values; # fixed - replace all negative values for 0.001;
              shift - shift each band by its minimum value, so every band has only positive values;
              shift_all - shift each band by the minimum value of all bands. All bands will be shifted up by the
              same amount
      :return: nd arrays without negatives values



.. py:class:: DWConfig(config_file=None)


   Bases: :py:obj:`DWBaseConfig`

   .. py:property:: reference_band


   .. py:property:: create_composite


   .. py:property:: pdf_reports


   .. py:property:: calc_glint


   .. py:property:: glint_mode


   .. py:property:: min_glint_multiplier


   .. py:property:: pdf_resolution


   .. py:property:: pekel_water


   .. py:property:: pekel_accuracy


   .. py:property:: save_indices


   .. py:property:: texture_stretching


   .. py:property:: external_mask


   .. py:property:: mask_name


   .. py:property:: mask_valid_value


   .. py:property:: mask_invalid_value


   .. py:property:: maximum_invalid


   .. py:property:: average_results


   .. py:property:: min_positive_pixels


   .. py:property:: clustering_method


   .. py:property:: linkage


   .. py:property:: train_size


   .. py:property:: regularization


   .. py:property:: min_train_size


   .. py:property:: max_train_size


   .. py:property:: score_index


   .. py:property:: classifier


   .. py:property:: detect_water_cluster


   .. py:property:: min_clusters


   .. py:property:: max_clusters


   .. py:property:: plot_graphs


   .. py:property:: graphs_bands


   .. py:property:: plot_ts


   .. py:property:: clustering_bands


   .. py:property:: clip_band


   .. py:property:: clip_inf_value


   .. py:property:: clip_sup_value


   .. py:attribute:: _config_file
      :value: 'WaterDetect.ini'

      

   .. py:attribute:: _defaults

      

   .. py:method:: get_masks_list(product)



.. py:function:: prepare_external_masks(imgs_dir, masks_dir, flags, img_type = 'S2_S2COR', msk_type = 'S2_S2COR', dilation=0)


